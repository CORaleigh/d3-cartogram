<!DOCTYPE html>
<html>
  <head>
    <title>Cartogram</title>
    <meta charset="utf-8">
    <script src="http://d3js.org/d3.v2.min.js"></script>
    <script src="colorbrewer/colorbrewer.js"></script>
    <script src="topojson.js"></script>
    <script src="cartogram.js"></script>
    <style type="text/css">

      html, body {
        height: 100%;
        padding: 0;
        margin: 0;
      }

      #map {
        display: block;
        width: 100%;
        height: 100%;
        background: #f8f8f8;
      }

      path.state {
        stroke: #666;
        stroke-width: .5;
      }

    </style>
  </head>
  <body>
    <svg id="map"></svg>
    <script>

      var map = d3.select("#map"),
          zoom = d3.behavior.zoom()
            .translate([55, 30])
            .scale(1)
            .scaleExtent([0.5, 10.0])
            .on("zoom", updateZoom),
          layer = map.append("g")
            .attr("id", "layer"),
          states = layer.append("g")
            .attr("id", "states")
            .selectAll("path");

      d3.select("body").call(zoom);
      updateZoom();

      function updateZoom() {
        var scale = zoom.scale();
        layer.attr("transform",
          "translate(" + zoom.translate() + ") " +
          "scale(" + [scale, scale] + ")");
      }

      var proj = d3.geo.albersUsa(),
          // identity projection
          ident = function(c) { return c; },
          topology,
          dataById = {},
          field = location.search.substr(1) || "POPESTIMATE2011",
          fmt = d3.format("+0,"),
          carto = d3.cartogram()
            .iterations(4)
            .projection(proj)
            .properties(function(d) {
              return dataById[d.id];
            })
            .value(function(d) {
              return +d.properties[field];
            });

      d3.json("data/us-states.json", function(topo) {
        topology = topo;
        d3.csv("data/nst_2011.csv", function(data) {

          dataById = d3.nest()
            .key(function(d) { return d.STATE; })
            .rollup(function(d) { return d[0]; })
            .map(data);

          init();
        });
      });

      function init() {

        var features = carto.features(topology),
            path = d3.geo.path()
              .projection(proj);

        states = states.data(features)
          .enter()
          .append("path")
            .attr("class", "state")
            .attr("id", function(d) {
              return d.properties.NAME;
            })
            .attr("fill", "#ccc")
            .attr("d", path);

        states.append("title");

        setTimeout(update, 10);
      }

      function update() {
        var value = function(d) {
              return +d.properties[field];
            },
            values = states.data()
              .map(value)
              .filter(function(n) {
                return !isNaN(n);
              })
              .sort(d3.ascending),
            lo = values[0],
            hi = values[values.length - 1];

        var scheme = colorbrewer.RdBu,
            color = d3.scale.linear();
        if (lo < 0) {
          color.domain([lo, 0, hi])
            .range(scheme[3]);
          map.classed("diverging", true);
        } else {
          color.domain([lo, d3.mean(values), hi])
            .range(scheme[3]);
        }


        var scale = d3.scale.linear()
          .domain([lo, hi])
          .range([10, 1000]);

        carto.value(function(d) {
          return scale(value(d));
        });

        var features = carto(topology),
            path = d3.geo.path()
              .projection(ident);

        states.data(features)
          .select("title")
            .text(function(d) {
              return [d.properties.NAME, fmt(value(d))].join(": ");
            });

        states.transition()
          .duration(1000)
          .ease("linear")
          .attr("fill", function(d) {
            return color(value(d));
          })
          .attr("d", path);
      }

    </script>
  </body>
</html>
